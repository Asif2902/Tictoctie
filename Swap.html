<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MON DEX Interface</title>
  <style>
    /* Unchanged CSS */
    body {
      margin: 0;
      padding: 0;
      background: #000000;
      color: #e0e0e0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #app { max-width: 1200px; margin: 0 auto; padding: 20px; }
    header, footer { text-align: center; margin-bottom: 20px; }
    header h1 { margin: 0; font-size: 2.5rem; color: #ff00ff; }
    button { background: #6a0dad; color: #fff; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; transition: background 0.3s ease; }
    button:hover { background: #4b0082; }
    #connectWallet { margin-top: 10px; font-weight: bold; }
    nav { display: flex; justify-content: center; gap: 20px; margin-bottom: 20px; }
    nav .tabButton { background: #1a1a1a; padding: 10px 20px; border-radius: 6px; border: none; cursor: pointer; color: #e0e0e0; transition: background 0.3s ease; }
    nav .tabButton.active, nav .tabButton:hover { background: #ff00ff; }
    .tabContent { display: none; animation: fadeIn 0.3s ease-in-out; }
    .tabContent.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .swap-container, .liquidity-container, .scrollable { background: #111; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
    .input-row { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
    .token-select { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #333; border-radius: 6px; cursor: pointer; min-width: 140px; transition: background 0.3s; }
    .token-select:hover { background: #444; }
    .tokenLogo { width: 24px; height: 24px; border-radius: 50%; object-fit: cover; }
    input[type="number"], input[type="text"] { padding: 10px; background: #222; border: 1px solid #444; border-radius: 6px; color: #e0e0e0; flex: 1; }
    .balanceInfo { font-size: 0.9rem; color: #aaa; margin-top: 5px; }
    .switchButton { background: none; border: none; font-size: 2rem; color: #e0e0e0; cursor: pointer; transition: transform 0.3s; }
    .switchButton:hover { transform: rotate(90deg); }
    .priceImpactInfo { margin: 10px 0; font-size: 0.9rem; color: #ffcc00; }
    .actionButton { width: 100%; padding: 15px; font-size: 1rem; font-weight: bold; margin-top: 10px; }
    .scrollable { max-height: 250px; overflow-y: auto; background: #222; padding: 10px; border-radius: 6px; }
    .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); }
    .modal-content { background: #111; margin: 10% auto; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; position: relative; }
    .close-modal { position: absolute; top: 10px; right: 15px; font-size: 1.5rem; cursor: pointer; color: #e0e0e0; }
    .notification { position: fixed; bottom: 20px; right: 20px; background: #333; padding: 15px 20px; border-radius: 6px; display: none; color: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.5); z-index: 200; }
    .lpTokenItem { padding: 10px; border-bottom: 1px solid #444; cursor: pointer; transition: background 0.3s; }
    .lpTokenItem:hover, .lpTokenItem.selected { background: #333; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>MON DEX</h1>
      <button id="connectWallet">Connect Wallet</button>
    </header>

    <!-- Navigation Tabs -->
    <nav>
      <button class="tabButton active" data-tab="swapTab">Swap</button>
      <button class="tabButton" data-tab="liquidityTab">Liquidity</button>
      <button class="tabButton" data-tab="myLiquidityTab">My Liquidity</button>
    </nav>

    <main>
      <!-- Swap Section -->
      <section id="swapTab" class="tabContent active">
        <h2>Swap Tokens</h2>
        <div class="swap-container">
          <!-- Input: From -->
          <div class="swap-input">
            <label>From</label>
            <div class="input-row">
              <div class="token-select" data-target="swapTokenA">
                <img src="https://via.placeholder.com/24" alt="Token Logo" class="tokenLogo" id="swapLogoA">
                <span id="swapTokenASymbol">Select Token</span>
              </div>
              <input type="number" id="swapAmountIn" placeholder="0">
              <button id="maxSwap">MAX</button>
            </div>
            <div class="balanceInfo" id="balanceSwapIn">Balance: 0</div>
          </div>
          <!-- Switch Button -->
          <button id="switchSwap" class="switchButton">⇆</button>
          <!-- Input: To -->
          <div class="swap-input">
            <label>To</label>
            <div class="input-row">
              <div class="token-select" data-target="swapTokenB">
                <img src="https://via.placeholder.com/24" alt="Token Logo" class="tokenLogo" id="swapLogoB">
                <span id="swapTokenBSymbol">Select Token</span>
              </div>
              <input type="number" id="swapAmountOut" placeholder="0" readonly>
              <span id="swapAmountOutUSD"></span>
            </div>
            <div class="balanceInfo" id="balanceSwapOut">Balance: 0</div>
          </div>
          <!-- Price Impact -->
          <div class="priceImpactInfo" id="priceImpactSection">
            Price Impact: <span id="priceImpact">0%</span>
          </div>
          <button id="swapButton" class="actionButton">Swap</button>
        </div>
      </section>

      <!-- Liquidity Section (only for adding liquidity) -->
      <section id="liquidityTab" class="tabContent">
        <h2>Add Liquidity</h2>
        <div class="liquidity-container">
          <!-- Token A for Liquidity -->
          <div class="liquidity-input">
            <label>Token A</label>
            <div class="input-row">
              <div class="token-select" data-target="liqTokenA">
                <img src="https://via.placeholder.com/24" alt="Token Logo" class="tokenLogo" id="liqLogoA">
                <span id="liqTokenASymbol">Select Token</span>
              </div>
              <input type="number" id="liqAmountA" placeholder="0">
            </div>
            <div class="balanceInfo" id="balanceLiqA">Balance: 0</div>
          </div>
          <!-- Token B for Liquidity -->
          <div class="liquidity-input">
            <label>Token B</label>
            <div class="input-row">
              <div class="token-select" data-target="liqTokenB">
                <img src="https://via.placeholder.com/24" alt="Token Logo" class="tokenLogo" id="liqLogoB">
                <span id="liqTokenBSymbol">Select Token</span>
              </div>
              <input type="number" id="liqAmountB" placeholder="0">
            </div>
            <div class="balanceInfo" id="balanceLiqB">Balance: 0</div>
          </div>
          <button id="addLiquidityButton" class="actionButton">Add Liquidity</button>
        </div>
      </section>

      <!-- My Liquidity Section (for listing and removing liquidity) -->
      <section id="myLiquidityTab" class="tabContent">
        <h2>My Liquidity Positions</h2>
        <div id="myLiquidityList" class="scrollable">
          <p>No liquidity positions found.</p>
        </div>
        <button id="importLPButton" class="actionButton">Import LP Token</button>
        <div id="lpRemovalSection" style="display:none;">
          <label for="removeSlider">Remove %: <span id="removePercent">0%</span></label>
          <input type="range" id="removeSlider" min="0" max="99.9999" step="0.0001" value="0">
          <button id="removeLiquidityButton" class="actionButton">Remove Liquidity</button>
        </div>
      </section>
    </main>

    <!-- Token Selection Modal -->
    <div id="tokenModal" class="modal">
      <div class="modal-content">
        <span class="close-modal" id="closeTokenModal">×</span>
        <h3>Select a Token</h3>
        <input type="text" id="tokenSearch" placeholder="Search by symbol or paste address">
        <div id="tokenList" class="scrollable">
        </div>
      </div>
    </div>

    <div id="notification" class="notification"></div>
    <footer>
      <p>MON Testnet | Explorer: testnet.monadexplorer.com</p>
    </footer>
  </div>

  <!-- Include ethers.js -->
  <script src="https://ttt.0xasif.monster/ethers.js"></script>
  <script>
    // Network & Contract Info
    const PRIMARY_RPC = "https://testnet-rpc.monad.xyz";
    const CHAIN_ID = 10143; // 0x279f
    const CHAIN_HEX = "0x279f";
    const CURRENCY = "MON";
    const MON_PRICE = 11; // Hardcoded USD price
    const ROUTER_ADDRESS = "0x144e18DB06B4553b94ED397610D2FBf809790545";
    const FACTORY_ADDRESS = "0xc98d287eFCBbb177D641FD2105dEC57996335766";
    const WMON_ADDRESS = "0xf6C4e67A551bd10444e3b439A4Eb19ec46eC1215"; // Wrapped MON

const routerABI = [
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_factory",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_WETH",
				"type": "address"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [],
		"name": "WETH",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenA",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "tokenB",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amountADesired",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountBDesired",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountAMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountBMin",
				"type": "uint256"
			}
		],
		"name": "addLiquidity",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amountA",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountB",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "liquidity",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amountTokenDesired",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountTokenMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountETHMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "addLiquidityETH",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amountToken",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountETH",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "liquidity",
				"type": "uint256"
			}
		],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "factory",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountOut",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "reserveIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "reserveOut",
				"type": "uint256"
			}
		],
		"name": "getAmountIn",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			}
		],
		"stateMutability": "pure",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "reserveIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "reserveOut",
				"type": "uint256"
			}
		],
		"name": "getAmountOut",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amountOut",
				"type": "uint256"
			}
		],
		"stateMutability": "pure",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountOut",
				"type": "uint256"
			},
			{
				"internalType": "address[]",
				"name": "path",
				"type": "address[]"
			}
		],
		"name": "getAmountsIn",
		"outputs": [
			{
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "address[]",
				"name": "path",
				"type": "address[]"
			}
		],
		"name": "getAmountsOut",
		"outputs": [
			{
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenA",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "tokenB",
				"type": "address"
			}
		],
		"name": "getReserves",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "reserveA",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "reserveB",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountA",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "reserveA",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "reserveB",
				"type": "uint256"
			}
		],
		"name": "quote",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amountB",
				"type": "uint256"
			}
		],
		"stateMutability": "pure",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenA",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "tokenB",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "liquidity",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountAMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountBMin",
				"type": "uint256"
			}
		],
		"name": "removeLiquidity",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amountA",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountB",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "liquidity",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountTokenMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountETHMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "removeLiquidityETH",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amountToken",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountETH",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenA",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "tokenB",
				"type": "address"
			}
		],
		"name": "sortTokens",
		"outputs": [
			{
				"internalType": "address",
				"name": "token0",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "token1",
				"type": "address"
			}
		],
		"stateMutability": "pure",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "stableOut",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "stableCoin",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "swapExactETHForStableCoin",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "stableAmountOut",
				"type": "uint256"
			}
		],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "address[]",
				"name": "path",
				"type": "address[]"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "swapExactETHForTokens",
		"outputs": [
			{
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			}
		],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "stableIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "ethOut",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "stableCoin",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "swapExactStableCoinForETH",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "ethAmountOut",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "tokenIn",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "tokenOut",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "swapExactStableForStable",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amountOut",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "address[]",
				"name": "path",
				"type": "address[]"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "swapExactTokensForETH",
		"outputs": [
			{
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "address[]",
				"name": "path",
				"type": "address[]"
			}
		],
		"name": "swapExactTokensForTokens",
		"outputs": [
			{
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"stateMutability": "payable",
		"type": "receive"
	}
];
const factoryABI =[
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_feeToSetter",
				"type": "address"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token0",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "token1",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "pair",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "PairCreated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "stableCoin",
				"type": "address"
			}
		],
		"name": "StableCoinAdded",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			}
		],
		"name": "addStableCoin",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "allPairs",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "allPairsLength",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenA",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "tokenB",
				"type": "address"
			}
		],
		"name": "createPair",
		"outputs": [
			{
				"internalType": "address",
				"name": "pair",
				"type": "address"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "feeTo",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "feeToSetter",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "getPair",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "isStableCoin",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_feeTo",
				"type": "address"
			}
		],
		"name": "setFeeTo",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_feeToSetter",
				"type": "address"
			}
		],
		"name": "setFeeToSetter",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}
];
const erc20ABI = [
    {"constant": true, "inputs": [], "name": "name", "outputs": [{"name": "", "type": "string"}], "type": "function"},
    {"constant": true, "inputs": [], "name": "symbol", "outputs": [{"name": "", "type": "string"}], "type": "function"},
    {"constant": true, "inputs": [], "name": "decimals", "outputs": [{"name": "", "type": "uint8"}], "type": "function"},
    {"constant": true, "inputs": [{"name": "_owner", "type": "address"}], "name": "balanceOf", "outputs": [{"name": "balance", "type": "uint256"}], "type": "function"},
    {"constant": false, "inputs": [{"name": "_to", "type": "address"}, {"name": "_value", "type": "uint256"}], "name": "transfer", "outputs": [{"name": "", "type": "bool"}], "type": "function"},
    {"constant": false, "inputs": [{"name": "_spender", "type": "address"}, {"name": "_value", "type": "uint256"}], "name": "approve", "outputs": [{"name": "", "type": "bool"}], "type": "function"},
    {"constant": true, "inputs": [{"name": "_owner", "type": "address"}, {"name": "_spender", "type": "address"}], "name": "allowance", "outputs": [{"name": "", "type": "uint256"}], "type": "function"}
  ];
const lpTokenABI = [
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Approval",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount0",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount1",
				"type": "uint256"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			}
		],
		"name": "Burn",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount0",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount1",
				"type": "uint256"
			}
		],
		"name": "Mint",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount0In",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount1In",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount0Out",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount1Out",
				"type": "uint256"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			}
		],
		"name": "Swap",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "uint112",
				"name": "reserve0",
				"type": "uint112"
			},
			{
				"indexed": false,
				"internalType": "uint112",
				"name": "reserve1",
				"type": "uint112"
			}
		],
		"name": "Sync",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "allowance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "approve",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			}
		],
		"name": "burn",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amount0",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amount1",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "decimals",
		"outputs": [
			{
				"internalType": "uint8",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "factory",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getReserves",
		"outputs": [
			{
				"internalType": "uint112",
				"name": "_reserve0",
				"type": "uint112"
			},
			{
				"internalType": "uint112",
				"name": "_reserve1",
				"type": "uint112"
			},
			{
				"internalType": "uint32",
				"name": "_blockTimestampLast",
				"type": "uint32"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_token0",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_token1",
				"type": "address"
			}
		],
		"name": "initialize",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "kLast",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			}
		],
		"name": "mint",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "liquidity",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "name",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "price0CumulativeLast",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "price1CumulativeLast",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amount0Out",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amount1Out",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "bytes",
				"name": "data",
				"type": "bytes"
			}
		],
		"name": "swap",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "symbol",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "sync",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "token0",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "token1",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalSupply",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "transfer",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "transferFrom",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	}
];
const wmonABI = [
    {"inputs": [], "name": "deposit", "outputs": [], "stateMutability": "payable", "type": "function"},
    {"inputs": [{"name": "wad", "type": "uint256"}], "name": "withdraw", "outputs": [], "stateMutability": "nonpayable", "type": "function"}
  ];
    // Default Token List
    const defaultTokens = [
      { symbol: "USDC", address: "0xf817257fed379853cDe0fa4F97AB987181B1E5Ea", decimals: 6, logo: "https://cryptologos.cc/logos/usd-coin-usdc-logo.png?v=023" },
      { symbol: "USDT", address: "0x88b8E2161DEDC77EF4ab7585569D2415a1C1055D", decimals: 6, logo: "https://cryptologos.cc/logos/tether-usdt-logo.png?v=040" },
      { symbol: "WMON", address: "0xf6C4e67A551bd10444e3b439A4Eb19ec46eC1215", decimals: 18, logo: "https://imagedelivery.net/cBNDGgkrsEA-b_ixIp9SkQ/I_t8rg_V_400x400.jpg/public" },
      { symbol: "MON", address: "MON", decimals: 18, logo: "https://cdn.prod.website-files.com/667c57e6f9254a4b6d914440/667d7104644c621965495f6e_LogoMark.svg" }
    ];
    let tokenList = [...defaultTokens];

    // Global State Variables
    let provider = new ethers.providers.StaticJsonRpcProvider(PRIMARY_RPC, { chainId: CHAIN_ID, name: "monad" });
    let signer;
    let userAddress;
    let currentChainId;
    let selectedTokenTarget = "";
    let selectedSwapTokenA = null;
    let selectedSwapTokenB = null;
    let selectedLiqTokenA = null;
    let selectedLiqTokenB = null;

    // Utility Functions
    function notify(message, type = "info") {
      const notif = document.getElementById("notification");
      notif.textContent = message;
      notif.style.backgroundColor = type === "success" ? "#4caf50" : type === "error" ? "#f44336" : "#333";
      notif.style.display = "block";
      setTimeout(() => { notif.style.display = "none"; }, 3000);
    }

    function abbreviateNumber(num) {
      if (num >= 1e12) return (num / 1e12).toFixed(2) + "T";
      if (num >= 1e9) return (num / 1e9).toFixed(2) + "B";
      if (num >= 1e6) return (num / 1e6).toFixed(2) + "M";
      if (num >= 1e3) return (num / 1e3).toFixed(2) + "K";
      return parseFloat(num).toFixed(5);
    }

    function throttle(func, limit) {
      let lastFunc;
      let lastRan;
      return function (...args) {
        const context = this;
        if (!lastRan) {
          func.apply(context, args);
          lastRan = Date.now();
        } else {
          clearTimeout(lastFunc);
          lastFunc = setTimeout(() => {
            if ((Date.now() - lastRan) >= limit) {
              func.apply(context, args);
              lastRan = Date.now();
            }
          }, limit - (Date.now() - lastRan));
        }
      };
    }

    async function isStable(tokenAddress) {
      const factoryContract = new ethers.Contract(FACTORY_ADDRESS, factoryABI, provider);
      return await factoryContract.isStableCoin(tokenAddress);
    }

    // Wallet & Network Connection
    async function connectWallet() {
      if (window.ethereum) {
        try {
          await window.ethereum.request({ method: "eth_requestAccounts" });
          const web3Provider = new ethers.providers.Web3Provider(window.ethereum);
          signer = web3Provider.getSigner();
          userAddress = await signer.getAddress();
          currentChainId = (await web3Provider.getNetwork()).chainId;
          if (currentChainId !== CHAIN_ID) {
            await switchToCorrectChain();
          }
          notify("Wallet connected: " + userAddress.slice(0, 6) + "...", "success");
          document.getElementById("connectWallet").style.display = "none";
          updateCurrentTabData();
        } catch (error) {
          notify("Wallet connection failed: " + error.message, "error");
        }
      } else {
        notify("No wallet provider found", "error");
      }
    }

    async function switchToCorrectChain() {
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: CHAIN_HEX }]
        });
        currentChainId = CHAIN_ID;
        notify("Switched to correct chain", "success");
      } catch (switchError) {
        notify("Chain switch failed: " + switchError.message, "error");
      }
    }

    if (window.ethereum) {
      window.ethereum.on('chainChanged', (chainId) => {
        if (parseInt(chainId, 16) !== CHAIN_ID) {
          notify("Please switch to the correct chain", "error");
        } else {
          notify("Chain switched", "success");
          updateCurrentTabData();
        }
      });
    }

    // Tab Switching
    document.querySelectorAll(".tabButton").forEach(button => {
      button.addEventListener("click", () => {
        document.querySelectorAll(".tabButton").forEach(btn => btn.classList.remove("active"));
        document.querySelectorAll(".tabContent").forEach(tab => tab.classList.remove("active"));
        button.classList.add("active");
        document.getElementById(button.dataset.tab).classList.add("active");
        updateCurrentTabData();
      });
    });

    function updateCurrentTabData() {
      const activeTab = document.querySelector(".tabContent.active").id;
      if (activeTab === "swapTab") {
        fetchSwapBalances();
      } else if (activeTab === "liquidityTab") {
        fetchLiquidityBalances();
      } else if (activeTab === "myLiquidityTab") {
        fetchLPPositions();
      }
    }

    // Token Modal & Selector
    function updateTokenListUI() {
      const tokenListDiv = document.getElementById("tokenList");
      tokenListDiv.innerHTML = "";
      tokenList.forEach(token => {
        const logoUrl = token.logo || "https://via.placeholder.com/24?text=%3F";
        const tokenDiv = document.createElement("div");
        tokenDiv.className = "token-item";
        tokenDiv.innerHTML = `<img src="${logoUrl}" alt="${token.symbol}" class="tokenLogo">
                              <span>${token.symbol}</span>`;
        tokenDiv.addEventListener("click", () => selectToken(token));
        tokenListDiv.appendChild(tokenDiv);
      });
    }

    function openTokenModal(target) {
      selectedTokenTarget = target;
      document.getElementById("tokenModal").style.display = "block";
      updateTokenListUI();
    }

    function closeTokenModal() {
      document.getElementById("tokenModal").style.display = "none";
      document.getElementById("tokenSearch").value = "";
    }

    document.getElementById("closeTokenModal").addEventListener("click", closeTokenModal);

    document.getElementById("tokenSearch").addEventListener("input", async (e) => {
      const query = e.target.value.toLowerCase();
      if (query.startsWith("0x") && query.length === 42) {
        try {
          const tokenContract = new ethers.Contract(query, erc20ABI, provider);
          const symbol = await tokenContract.symbol();
          const decimals = await tokenContract.decimals();
          const newToken = { symbol, address: query, decimals, logo: "https://via.placeholder.com/24?text=" + symbol };
          if (!tokenList.some(t => t.address.toLowerCase() === query.toLowerCase())) {
            tokenList.push(newToken);
            localStorage.setItem("importedTokens", JSON.stringify(tokenList.filter(t => !defaultTokens.some(dt => dt.address === t.address))));
            notify("Token imported successfully", "success");
          }
          updateTokenListUI();
        } catch (error) {
          notify("Invalid token address", "error");
        }
      } else {
        const tokenListDiv = document.getElementById("tokenList");
        tokenListDiv.innerHTML = "";
        tokenList.filter(token => token.symbol.toLowerCase().includes(query) || token.address.toLowerCase() === query)
          .forEach(token => {
            const logoUrl = token.logo || "https://via.placeholder.com/24?text=%3F";
            const tokenDiv = document.createElement("div");
            tokenDiv.className = "token-item";
            tokenDiv.innerHTML = `<img src="${logoUrl}" alt="${token.symbol}" class="tokenLogo">
                                  <span>${token.symbol}</span>`;
            tokenDiv.addEventListener("click", () => selectToken(token));
            tokenListDiv.appendChild(tokenDiv);
          });
      }
    });

    function selectToken(token) {
      if (selectedTokenTarget === "swapTokenA") {
        selectedSwapTokenA = token;
        document.getElementById("swapLogoA").src = token.logo || "https://via.placeholder.com/24?text=%3F";
        document.getElementById("swapTokenASymbol").textContent = token.symbol;
        fetchBalanceForToken(token, "balanceSwapIn");
      } else if (selectedTokenTarget === "swapTokenB") {
        selectedSwapTokenB = token;
        document.getElementById("swapLogoB").src = token.logo || "https://via.placeholder.com/24?text=%3F";
        document.getElementById("swapTokenBSymbol").textContent = token.symbol;
        fetchBalanceForToken(token, "balanceSwapOut");
      } else if (selectedTokenTarget === "liqTokenA") {
        selectedLiqTokenA = token;
        document.getElementById("liqLogoA").src = token.logo || "https://via.placeholder.com/24?text=%3F";
        document.getElementById("liqTokenASymbol").textContent = token.symbol;
        fetchBalanceForToken(token, "balanceLiqA");
      } else if (selectedTokenTarget === "liqTokenB") {
        selectedLiqTokenB = token;
        document.getElementById("liqLogoB").src = token.logo || "https://via.placeholder.com/24?text=%3F";
        document.getElementById("liqTokenBSymbol").textContent = token.symbol;
        fetchBalanceForToken(token, "balanceLiqB");
      }
      closeTokenModal();
    }

    document.querySelectorAll(".token-select").forEach(el => {
      el.addEventListener("click", () => openTokenModal(el.dataset.target));
    });

    // Balance Fetching
    const throttledFetchBalanceForToken = throttle(fetchBalanceForToken, 100);

    async function fetchBalanceForToken(token, balanceElementId) {
      if (!userAddress) return;
      try {
        let balance;
        if (token.address === "MON") {
          balance = await provider.getBalance(userAddress);
        } else {
          const tokenContract = new ethers.Contract(token.address, erc20ABI, provider);
          balance = await tokenContract.balanceOf(userAddress);
        }
        balance = ethers.utils.formatUnits(balance, token.decimals);
        const priceUSD = getTokenPriceUSD(token);
        let balanceText = "Balance: " + abbreviateNumber(balance);
        if (priceUSD) {
          const balanceUSD = (parseFloat(balance) * priceUSD).toFixed(2);
          balanceText += ` ($${balanceUSD})`;
        }
        document.getElementById(balanceElementId).textContent = balanceText;
      } catch (error) {
        console.error(`Error fetching balance for ${token.symbol}:`, error);
      }
    }

    function fetchSwapBalances() {
      if (selectedSwapTokenA) throttledFetchBalanceForToken(selectedSwapTokenA, "balanceSwapIn");
      if (selectedSwapTokenB) throttledFetchBalanceForToken(selectedSwapTokenB, "balanceSwapOut");
    }

    function fetchLiquidityBalances() {
      if (selectedLiqTokenA) throttledFetchBalanceForToken(selectedLiqTokenA, "balanceLiqA");
      if (selectedLiqTokenB) throttledFetchBalanceForToken(selectedLiqTokenB, "balanceLiqB");
    }

    // Approval Function
    async function ensureApproval(token, amount, spender) {
      if (token.address === "MON") return true; // No approval needed for MON
      const tokenContract = new ethers.Contract(token.address, erc20ABI, signer);
      const allowance = await tokenContract.allowance(userAddress, spender);
      if (allowance.lt(amount)) {
        notify(`Approving ${token.symbol}...`, "info");
        const tx = await tokenContract.approve(spender, amount);
        await tx.wait();
        notify(`${token.symbol} approved successfully`, "success");
      }
      return true;
    }

    // Wrap/Unwrap Functions
    async function wrapMon(amount) {
      const wmonContract = new ethers.Contract(WMON_ADDRESS, wmonABI, signer);
      const tx = await wmonContract.deposit({ value: amount });
      notify("Wrapping MON to WMON...", "info");
      await tx.wait();
      notify("Wrapped successfully", "success");
    }

    async function unwrapMon(amount) {
      const wmonContract = new ethers.Contract(WMON_ADDRESS, wmonABI, signer);
      const tx = await wmonContract.withdraw(amount);
      notify("Unwrapping WMON to MON...", "info");
      await tx.wait();
      notify("Unwrapped successfully", "success");
    }

    // Token Price in USD
    function getTokenPriceUSD(token) {
      if (token.symbol === "MON" || token.symbol === "WMON") return 11;
      return null; // Stablecoin price assumed 1 USD, determined dynamically
    }

    // Price Impact Calculation
    async function calculatePriceImpact(tokenIn, tokenOut, amountInRaw) {
      if (!tokenIn || !tokenOut || !amountInRaw || parseFloat(amountInRaw) <= 0) return "0%";
      if ((tokenIn.symbol === "MON" && tokenOut.symbol === "WMON") || 
          (tokenIn.symbol === "WMON" && tokenOut.symbol === "MON")) {
        return "0% (1:1)";
      }
      const isStableIn = await isStable(tokenIn.address);
      const isStableOut = await isStable(tokenOut.address);
      if (isStableIn && isStableOut) {
        return "0% (Stable)";
      }
      const amountIn = ethers.utils.parseUnits(amountInRaw, tokenIn.decimals);
      let tokenA = tokenIn.address === "MON" ? WMON_ADDRESS : tokenIn.address;
      let tokenB = tokenOut.address === "MON" ? WMON_ADDRESS : tokenOut.address;
      const factoryContract = new ethers.Contract(FACTORY_ADDRESS, factoryABI, provider);
      const pairAddress = await factoryContract.getPair(tokenA, tokenB);
      if (pairAddress === ethers.constants.AddressZero) {
        return "N/A (No Pair)";
      }
      const pairContract = new ethers.Contract(pairAddress, lpTokenABI, provider);
      const [reserve0, reserve1] = await pairContract.getReserves();
      const token0 = await pairContract.token0();
      let reserveA = tokenA.toLowerCase() === token0.toLowerCase() ? reserve0 : reserve1;
      let reserveB = tokenA.toLowerCase() === token0.toLowerCase() ? reserve1 : reserve0;
      if (reserveA.isZero() || reserveB.isZero()) {
        return "0% (Empty Reserves)";
      }
      const currentPrice = reserveB.mul(ethers.BigNumber.from(10).pow(18)).div(reserveA);
      const routerContract = new ethers.Contract(ROUTER_ADDRESS, routerABI, provider);
      const path = [tokenA, tokenB];
      const amountsOut = await routerContract.getAmountsOut(amountIn, path);
      const amountOut = amountsOut[1];
      if (amountOut.isZero()) {
        return "100% (No liquidity)";
      }
      const effectivePrice = amountOut.mul(ethers.BigNumber.from(10).pow(18)).div(amountIn);
      const priceImpactBN = currentPrice.sub(effectivePrice).mul(10000).div(currentPrice);
      const priceImpact = priceImpactBN.toNumber() / 100;
      return priceImpact.toFixed(2) + "%";
    }

    // Swap Functions
    document.getElementById("maxSwap").addEventListener("click", async () => {
      if (!selectedSwapTokenA) return notify("Select a token first", "error");
      let balance;
      if (selectedSwapTokenA.address === "MON") {
        balance = await provider.getBalance(userAddress);
      } else {
        const tokenContract = new ethers.Contract(selectedSwapTokenA.address, erc20ABI, provider);
        balance = await tokenContract.balanceOf(userAddress);
      }
      balance = ethers.utils.formatUnits(balance, selectedSwapTokenA.decimals);
      document.getElementById("swapAmountIn").value = balance;
    });

    document.getElementById("switchSwap").addEventListener("click", () => {
      [selectedSwapTokenA, selectedSwapTokenB] = [selectedSwapTokenB, selectedSwapTokenA];
      if (selectedSwapTokenA) {
        document.getElementById("swapLogoA").src = selectedSwapTokenA.logo || "https://via.placeholder.com/24?text=%3F";
        document.getElementById("swapTokenASymbol").textContent = selectedSwapTokenA.symbol;
        fetchBalanceForToken(selectedSwapTokenA, "balanceSwapIn");
      }
      if (selectedSwapTokenB) {
        document.getElementById("swapLogoB").src = selectedSwapTokenB.logo || "https://via.placeholder.com/24?text=%3F";
        document.getElementById("swapTokenBSymbol").textContent = selectedSwapTokenB.symbol;
        fetchBalanceForToken(selectedSwapTokenB, "balanceSwapOut");
      }
    });

    document.getElementById("swapAmountIn").addEventListener("input", async () => {
      const amountInRaw = document.getElementById("swapAmountIn").value;
      if (!selectedSwapTokenA || !selectedSwapTokenB || !amountInRaw || parseFloat(amountInRaw) <= 0) {
        document.getElementById("swapAmountOut").value = "0";
        document.getElementById("swapAmountOutUSD").textContent = "";
        document.getElementById("priceImpact").textContent = "0%";
        document.getElementById("priceImpactSection").style.display = "block";
        return;
      }
      try {
        let amountIn = ethers.utils.parseUnits(amountInRaw, selectedSwapTokenA.decimals);
        const isStableIn = await isStable(selectedSwapTokenA.address);
        const isStableOut = await isStable(selectedSwapTokenB.address);
        if ((selectedSwapTokenA.symbol === "MON" && selectedSwapTokenB.symbol === "WMON") ||
            (selectedSwapTokenA.symbol === "WMON" && selectedSwapTokenB.symbol === "MON")) {
          const amountOutRaw = amountInRaw;
          document.getElementById("swapAmountOut").value = amountOutRaw;
          const priceUSD = getTokenPriceUSD(selectedSwapTokenB);
          if (priceUSD) {
            const amountOutUSD = (parseFloat(amountOutRaw) * priceUSD).toFixed(2);
            document.getElementById("swapAmountOutUSD").textContent = `~$${amountOutUSD}`;
          }
          document.getElementById("priceImpact").textContent = "0% (1:1)";
          document.getElementById("priceImpactSection").style.display = "block";
        } else if (isStableIn && isStableOut) {
          const amountOutRaw = amountInRaw;
          document.getElementById("swapAmountOut").value = amountOutRaw;
          document.getElementById("priceImpact").textContent = "0% (Stable)";
          document.getElementById("priceImpactSection").style.display = "none";
          const priceUSD = 1;
          const amountOutUSD = (parseFloat(amountOutRaw) * priceUSD).toFixed(2);
          document.getElementById("swapAmountOutUSD").textContent = `~$${amountOutUSD}`;
        } else {
          const routerContract = new ethers.Contract(ROUTER_ADDRESS, routerABI, provider);
          let path = [
            selectedSwapTokenA.address === "MON" ? WMON_ADDRESS : selectedSwapTokenA.address,
            selectedSwapTokenB.address === "MON" ? WMON_ADDRESS : selectedSwapTokenB.address
          ];
          let amountsOut = await routerContract.getAmountsOut(amountIn, path);
          let amountOut = amountsOut[amountsOut.length - 1];
          const amountOutRaw = ethers.utils.formatUnits(amountOut, selectedSwapTokenB.decimals);
          document.getElementById("swapAmountOut").value = amountOutRaw;
          const priceUSD = getTokenPriceUSD(selectedSwapTokenB);
          if (priceUSD) {
            const amountOutUSD = (parseFloat(amountOutRaw) * priceUSD).toFixed(2);
            document.getElementById("swapAmountOutUSD").textContent = `~$${amountOutUSD}`;
          }
          const priceImpact = await calculatePriceImpact(selectedSwapTokenA, selectedSwapTokenB, amountInRaw);
          document.getElementById("priceImpact").textContent = priceImpact;
          document.getElementById("priceImpactSection").style.display = "block";
        }
      } catch (error) {
        console.error("Error calculating swap output:", error);
        document.getElementById("swapAmountOut").value = "Error";
        document.getElementById("swapAmountOutUSD").textContent = "";
        document.getElementById("priceImpact").textContent = "Error";
        document.getElementById("priceImpactSection").style.display = "block";
      }
    });

    document.getElementById("swapButton").addEventListener("click", async () => {
      const amountInRaw = document.getElementById("swapAmountIn").value;
      if (!selectedSwapTokenA || !selectedSwapTokenB) return notify("Select both tokens", "error");
      if (!amountInRaw || parseFloat(amountInRaw) <= 0) return notify("Enter a valid amount", "error");

      let amountIn = ethers.utils.parseUnits(amountInRaw, selectedSwapTokenA.decimals);
      try {
        if ((selectedSwapTokenA.symbol === "MON" && selectedSwapTokenB.symbol === "WMON") ||
            (selectedSwapTokenA.symbol === "WMON" && selectedSwapTokenB.symbol === "MON")) {
          if (selectedSwapTokenA.symbol === "MON") {
            await wrapMon(amountIn);
          } else {
            await unwrapMon(amountIn);
          }
          fetchSwapBalances();
          return;
        }

        const routerContract = new ethers.Contract(ROUTER_ADDRESS, routerABI, signer);
        let deadline = Math.floor(Date.now() / 1000) + 600;
        let tx;
        const isStableIn = await isStable(selectedSwapTokenA.address);
        const isStableOut = await isStable(selectedSwapTokenB.address);
        if (isStableIn && isStableOut) {
          await ensureApproval(selectedSwapTokenA, amountIn, ROUTER_ADDRESS);
          tx = await routerContract.swapExactStableForStable(
            amountIn,
            selectedSwapTokenA.address,
            selectedSwapTokenB.address,
            deadline
          );
        } else {
          let path = [
            selectedSwapTokenA.address === "MON" ? WMON_ADDRESS : selectedSwapTokenA.address,
            selectedSwapTokenB.address === "MON" ? WMON_ADDRESS : selectedSwapTokenB.address
          ];
          let amountsOut = await routerContract.getAmountsOut(amountIn, path);
          let expectedOut = amountsOut[amountsOut.length - 1];
          let amountOutMin = expectedOut.mul(95).div(100);
          if (selectedSwapTokenA.address === "MON") {
            tx = await routerContract.swapExactETHForTokens(
              amountOutMin,
              path,
              userAddress,
              deadline,
              { value: amountIn }
            );
          } else if (selectedSwapTokenB.address === "MON") {
            await ensureApproval(selectedSwapTokenA, amountIn, ROUTER_ADDRESS);
            tx = await routerContract.swapExactTokensForETH(
              amountIn,
              amountOutMin,
              path,
              userAddress,
              deadline
            );
          } else {
            await ensureApproval(selectedSwapTokenA, amountIn, ROUTER_ADDRESS);
            tx = await routerContract.swapExactTokensForTokens(
              amountIn,
              amountOutMin,
              path
            );
          }
        }
        notify("Swap transaction sent", "info");
        await tx.wait();
        notify("Swap executed successfully", "success");
        fetchSwapBalances();
      } catch (error) {
        console.error("Swap error:", error);
        notify("Swap failed: " + (error.reason || error.message), "error");
      }
    });

    // Add Liquidity Functions
    document.getElementById("liqAmountA").addEventListener("input", async () => {
      if (!selectedLiqTokenA || !selectedLiqTokenB) return;
      const amountARaw = document.getElementById("liqAmountA").value;
      if (!amountARaw || parseFloat(amountARaw) <= 0) {
        document.getElementById("liqAmountB").value = "";
        return;
      }
      let amountA = ethers.utils.parseUnits(amountARaw, selectedLiqTokenA.decimals);
      let amountB;
      let tokenAForPair = selectedLiqTokenA.address === "MON" ? WMON_ADDRESS : selectedLiqTokenA.address;
      let tokenBForPair = selectedLiqTokenB.address === "MON" ? WMON_ADDRESS : selectedLiqTokenB.address;
      const factoryContract = new ethers.Contract(FACTORY_ADDRESS, factoryABI, provider);
      const pairAddress = await factoryContract.getPair(tokenAForPair, tokenBForPair);
      const isStableA = await isStable(tokenAForPair);
      const isStableB = await isStable(tokenBForPair);
      if (pairAddress !== ethers.constants.AddressZero) {
        const pairContract = new ethers.Contract(pairAddress, lpTokenABI, provider);
        const [reserve0, reserve1] = await pairContract.getReserves();
        let reserveA = tokenAForPair.toLowerCase() < tokenBForPair.toLowerCase() ? reserve0 : reserve1;
        let reserveB = tokenAForPair.toLowerCase() < tokenBForPair.toLowerCase() ? reserve1 : reserve0;
        if (reserveA.isZero()) return;
        if (isStableA && isStableB) {
          const decimalsA = selectedLiqTokenA.decimals;
          const decimalsB = selectedLiqTokenB.decimals;
          amountB = amountA.mul(ethers.BigNumber.from(10).pow(decimalsB)).div(ethers.BigNumber.from(10).pow(decimalsA));
        } else {
          amountB = amountA.mul(reserveB).div(reserveA);
        }
        document.getElementById("liqAmountB").value = ethers.utils.formatUnits(amountB, selectedLiqTokenB.decimals);
      }
    });

    document.getElementById("addLiquidityButton").addEventListener("click", async () => {
      if (!selectedLiqTokenA || !selectedLiqTokenB) return notify("Select both tokens", "error");
      const amountARaw = document.getElementById("liqAmountA").value;
      const amountBRaw = document.getElementById("liqAmountB").value;
      if (!amountARaw || parseFloat(amountARaw) <= 0) return notify("Enter a valid amount for Token A", "error");
      if (!amountBRaw || parseFloat(amountBRaw) <= 0) return notify("Enter a valid amount for Token B", "error");

      if (selectedLiqTokenA.decimals === undefined && selectedLiqTokenA.address !== "MON") {
        const tokenAContract = new ethers.Contract(selectedLiqTokenA.address, erc20ABI, provider);
        selectedLiqTokenA.decimals = await tokenAContract.decimals();
      }
      if (selectedLiqTokenB.decimals === undefined && selectedLiqTokenB.address !== "MON") {
        const tokenBContract = new ethers.Contract(selectedLiqTokenB.address, erc20ABI, provider);
        selectedLiqTokenB.decimals = await tokenBContract.decimals();
      }

      const amountA = ethers.utils.parseUnits(amountARaw, selectedLiqTokenA.decimals);
      const amountB = ethers.utils.parseUnits(amountBRaw, selectedLiqTokenB.decimals);
      const tokenAForPair = selectedLiqTokenA.address === "MON" ? WMON_ADDRESS : selectedLiqTokenA.address;
      const tokenBForPair = selectedLiqTokenB.address === "MON" ? WMON_ADDRESS : selectedLiqTokenB.address;

      let balanceA, balanceB;
      if (selectedLiqTokenA.address === "MON") {
        balanceA = await provider.getBalance(userAddress);
      } else {
        const tokenAContract = new ethers.Contract(selectedLiqTokenA.address, erc20ABI, provider);
        balanceA = await tokenAContract.balanceOf(userAddress);
      }
      if (selectedLiqTokenB.address === "MON") {
        balanceB = await provider.getBalance(userAddress);
      } else {
        const tokenBContract = new ethers.Contract(selectedLiqTokenB.address, erc20ABI, provider);
        balanceB = await tokenBContract.balanceOf(userAddress);
      }
      if (balanceA.lt(amountA)) return notify(`Insufficient ${selectedLiqTokenA.symbol} balance`, "error");
      if (balanceB.lt(amountB)) return notify(`Insufficient ${selectedLiqTokenB.symbol} balance`, "error");

      try {
        const deadline = Math.floor(Date.now() / 1000) + 600; // 10 minutes from now
        const routerContract = new ethers.Contract(ROUTER_ADDRESS, routerABI, signer);
        let tx;

        if (selectedLiqTokenA.address === "MON" || selectedLiqTokenB.address === "MON") {
          let token, amountTokenDesired, valueETH;
          if (selectedLiqTokenA.address === "MON") {
            token = selectedLiqTokenB;
            amountTokenDesired = amountB;
            valueETH = amountA;
          } else {
            token = selectedLiqTokenA;
            amountTokenDesired = amountA;
            valueETH = amountB;
          }
          console.log(`addLiquidityETH: Token=${token.symbol}, Amount=${ethers.utils.formatUnits(amountTokenDesired, token.decimals)}, ETH=${ethers.utils.formatEther(valueETH)}`);
          if (token.address !== "MON") await ensureApproval(token, amountTokenDesired, ROUTER_ADDRESS);
          tx = await routerContract.addLiquidityETH(
            token.address,
            amountTokenDesired,
            amountTokenDesired.mul(95).div(100), // amountTokenMin (5% slippage)
            valueETH.mul(95).div(100),           // amountETHMin (5% slippage)
            deadline,
            { value: valueETH, gasLimit: 6000000 }
          );
        } else {
          console.log(`addLiquidity: TokenA=${selectedLiqTokenA.symbol}, AmountA=${ethers.utils.formatUnits(amountA, selectedLiqTokenA.decimals)}, TokenB=${selectedLiqTokenB.symbol}, AmountB=${ethers.utils.formatUnits(amountB, selectedLiqTokenB.decimals)}`);
          await ensureApproval(selectedLiqTokenA, amountA, ROUTER_ADDRESS);
          await ensureApproval(selectedLiqTokenB, amountB, ROUTER_ADDRESS);
          tx = await routerContract.addLiquidity(
            selectedLiqTokenA.address,
            selectedLiqTokenB.address,
            amountA,
            amountB,
            amountA.mul(95).div(100), // amountAMin (5% slippage)
            amountB.mul(95).div(100), // amountBMin (5% slippage)
            { gasLimit: 6000000 }
          );
        }
        notify("Adding liquidity...", "info");
        await tx.wait();
        notify("Liquidity added successfully", "success");
        fetchLiquidityBalances();
        fetchLPPositions();
      } catch (error) {
        console.error("Add liquidity error:", error);
        let errorMessage = error.message;
        if (error.data && error.data.message) errorMessage = error.data.message;
        else if (error.reason) errorMessage = error.reason;
        notify("Liquidity addition failed: " + errorMessage, "error");
      }
    });

    // LP Removal
    document.getElementById("removeSlider").addEventListener("input", (e) => {
      document.getElementById("removePercent").textContent = e.target.value + "%";
    });

    document.getElementById("removeLiquidityButton").addEventListener("click", async () => {
      const lpTokenElem = document.querySelector("#myLiquidityList .lpTokenItem.selected");
      if (!lpTokenElem) return notify("Select an LP token", "error");

      const lpTokenAddress = lpTokenElem.dataset.address;
      const tokenA = lpTokenElem.dataset.tokenA;
      const tokenB = lpTokenElem.dataset.tokenB;
      const lpBalanceRaw = lpTokenElem.dataset.balance;
      const lpBalance = ethers.BigNumber.from(lpBalanceRaw);
      const removePercentage = parseFloat(document.getElementById("removeSlider").value) / 100;
      const amountToRemove = lpBalance.mul(ethers.BigNumber.from(Math.floor(removePercentage * 1e6))).div(ethers.BigNumber.from(1e6));

      try {
        const lpTokenContract = new ethers.Contract(lpTokenAddress, lpTokenABI, signer);
        await ensureApproval({ address: lpTokenAddress, decimals: 18 }, amountToRemove, ROUTER_ADDRESS);
        const routerContract = new ethers.Contract(ROUTER_ADDRESS, routerABI, signer);
        const deadline = Math.floor(Date.now() / 1000) + 600;

        const pairContract = new ethers.Contract(lpTokenAddress, lpTokenABI, provider);
        const [reserve0, reserve1] = await pairContract.getReserves();
        const totalSupply = await pairContract.totalSupply();
        const token0 = await pairContract.token0();
        const token1 = await pairContract.token1();

        const reserveA = tokenA.toLowerCase() === token0.toLowerCase() ? reserve0 : reserve1;
        const reserveB = tokenA.toLowerCase() === token0.toLowerCase() ? reserve1 : reserve0;

        const expectedAmountA = totalSupply.gt(0) ? amountToRemove.mul(reserveA).div(totalSupply) : ethers.BigNumber.from(0);
        const expectedAmountB = totalSupply.gt(0) ? amountToRemove.mul(reserveB).div(totalSupply) : ethers.BigNumber.from(0);

        const amountAMin = expectedAmountA.mul(95).div(100); // 5% slippage
        const amountBMin = expectedAmountB.mul(95).div(100); // 5% slippage

        const txOptions = { gasLimit: 300000 };
        let tx;

        if (tokenA.toLowerCase() === WMON_ADDRESS.toLowerCase()) {
          tx = await routerContract.removeLiquidityETH(
            tokenB,
            amountToRemove,
            amountBMin,
            amountAMin,
            deadline,
            txOptions
          );
        } else if (tokenB.toLowerCase() === WMON_ADDRESS.toLowerCase()) {
          tx = await routerContract.removeLiquidityETH(
            tokenA,
            amountToRemove,
            amountAMin,
            amountBMin,
            deadline,
            txOptions
          );
        } else {
          tx = await routerContract.removeLiquidity(
            tokenA,
            tokenB,
            amountToRemove,
            amountAMin,
            amountBMin,
            txOptions
          );
        }

        notify("Removing liquidity...", "info");
        await tx.wait();
        notify("Liquidity removed successfully", "success");
        fetchLiquidityBalances();
        fetchLPPositions();
      } catch (error) {
        console.error("LP removal error:", error);
        notify("Liquidity removal failed: " + (error.reason || error.message), "error");
      }
    });

    // Fetch LP Positions
    async function fetchLPPositions() {
      if (!userAddress) return;
      const factoryContract = new ethers.Contract(FACTORY_ADDRESS, factoryABI, provider);
      const allPairsLength = await factoryContract.allPairsLength();
      const lpListDiv = document.getElementById("myLiquidityList");
      const currentItems = new Map();
      lpListDiv.querySelectorAll(".lpTokenItem").forEach(item => {
        currentItems.set(item.dataset.address, item);
      });
      const newPairs = new Set();
      let hasPositions = false;

      for (let i = 0; i < allPairsLength; i++) {
        try {
          const pairAddress = await factoryContract.allPairs(i);
          if (pairAddress === ethers.constants.AddressZero) continue;
          const pairContract = new ethers.Contract(pairAddress, lpTokenABI, provider);
          const balance = await pairContract.balanceOf(userAddress);
          if (balance.gt(0)) {
            hasPositions = true;
            newPairs.add(pairAddress);
            const token0 = await pairContract.token0();
            const token1 = await pairContract.token1();
            const token0Contract = new ethers.Contract(token0, erc20ABI, provider);
            const token1Contract = new ethers.Contract(token1, erc20ABI, provider);
            const symbol0 = await token0Contract.symbol();
            const symbol1 = await token1Contract.symbol();
            const balanceFormatted = ethers.utils.formatUnits(balance, 18);
            const lpText = `${symbol0}-${symbol1} LP: ${balanceFormatted}`;
            
            let lpTokenDiv = currentItems.get(pairAddress);
            if (lpTokenDiv) {
              // Update existing item if balance changed
              if (lpTokenDiv.dataset.balance !== balance.toString()) {
                lpTokenDiv.dataset.balance = balance.toString();
                lpTokenDiv.innerHTML = lpText;
              }
            } else {
              // Create new item if it doesn't exist
              lpTokenDiv = document.createElement("div");
              lpTokenDiv.className = "lpTokenItem";
              lpTokenDiv.dataset.address = pairAddress;
              lpTokenDiv.dataset.tokenA = token0;
              lpTokenDiv.dataset.tokenB = token1;
              lpTokenDiv.dataset.balance = balance.toString();
              lpTokenDiv.innerHTML = lpText;
              lpTokenDiv.addEventListener("click", () => {
                document.querySelectorAll(".lpTokenItem").forEach(el => el.classList.remove("selected"));
                lpTokenDiv.classList.add("selected");
                document.getElementById("lpRemovalSection").style.display = "block";
              });
              lpListDiv.appendChild(lpTokenDiv);
            }
          }
        } catch (error) {
          console.error(`Error fetching pair ${i}:`, error);
        }
      }

      // Remove any pairs that are no longer present
      currentItems.forEach((item, pairAddress) => {
        if (!newPairs.has(pairAddress)) {
          lpListDiv.removeChild(item);
        }
      });

      // Update UI if no positions exist
      if (!hasPositions) {
        lpListDiv.innerHTML = "<p>No liquidity positions found.</p>";
      } else if (lpListDiv.querySelector("p")) {
        lpListDiv.removeChild(lpListDiv.querySelector("p"));
      }
    }

    // Import LP Token
    document.getElementById("importLPButton").addEventListener("click", async () => {
      const lpAddress = prompt("Enter LP token address:");
      if (!lpAddress || !ethers.utils.isAddress(lpAddress)) {
        notify("Invalid LP address", "error");
        return;
      }
      try {
        const lpContract = new ethers.Contract(lpAddress, lpTokenABI, provider);
        const balance = await lpContract.balanceOf(userAddress);
        if (balance.lte(0)) {
          notify("No balance found for this LP token", "error");
          return;
        }
        const token0 = await lpContract.token0();
        const token1 = await lpContract.token1();
        const token0Contract = new ethers.Contract(token0, erc20ABI, provider);
        const token1Contract = new ethers.Contract(token1, erc20ABI, provider);
        const symbol0 = await token0Contract.symbol();
        const symbol1 = await token1Contract.symbol();
        const lpListDiv = document.getElementById("myLiquidityList");
        const lpTokenDiv = document.createElement("div");
        lpTokenDiv.className = "lpTokenItem";
        lpTokenDiv.dataset.address = lpAddress;
        lpTokenDiv.dataset.tokenA = token0;
        lpTokenDiv.dataset.tokenB = token1;
        lpTokenDiv.dataset.balance = balance.toString();
        lpTokenDiv.innerHTML = `${symbol0}-${symbol1} LP: ${ethers.utils.formatUnits(balance, 18)}`;
        lpTokenDiv.addEventListener("click", () => {
          document.querySelectorAll(".lpTokenItem").forEach(el => el.classList.remove("selected"));
          lpTokenDiv.classList.add("selected");
          document.getElementById("lpRemovalSection").style.display = "block";
        });
        lpListDiv.appendChild(lpTokenDiv);
        notify("LP token imported successfully", "success");
      } catch (error) {
        console.error("Error importing LP:", error);
        notify("Failed to import LP: " + (error.reason || error.message), "error");
      }
    });

    // Polling & Data Updates
    setInterval(() => {
      updateCurrentTabData();
    }, 15000);

    window.addEventListener("load", () => {
      const imported = JSON.parse(localStorage.getItem("importedTokens") || "[]");
      tokenList = [...defaultTokens, ...imported];
      selectedSwapTokenA = tokenList.find(token => token.symbol === "MON");
      selectedSwapTokenB = tokenList.find(token => token.symbol === "USDT");
      if (selectedSwapTokenA) {
        document.getElementById("swapLogoA").src = selectedSwapTokenA.logo || "https://cdn.prod.website-files.com/667c57e6f9254a4b6d914440/667d7104644c621965495f6e_LogoMark.svg";
        document.getElementById("swapTokenASymbol").textContent = selectedSwapTokenA.symbol;
      }
      if (selectedSwapTokenB) {
        document.getElementById("swapLogoB").src = selectedSwapTokenB.logo || "https://cryptologos.cc/logos/tether-usdt-logo.png?v=040";
        document.getElementById("swapTokenBSymbol").textContent = selectedSwapTokenB.symbol;
      }
    });

    document.getElementById("connectWallet").addEventListener("click", connectWallet);
  </script>
</body>
</html>