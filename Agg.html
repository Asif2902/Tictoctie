<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dex Aggregator UI</title>
  <!-- Include ethers.js -->
  <script src="https://ttt.0xasif.monster/ethers.js"></script>
  <style>
    /* Base styles */
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f6f8;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header {
      width: 100%;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h2 { margin: 0; }
    .container {
      margin-top: 20px;
      width: 90%;
      max-width: 500px;
      background-color: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 20px;
    }
    .swap-section {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    label { font-weight: bold; margin-bottom: 5px; display: block; }
    .token-select {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      background-color: #fafafa;
      cursor: pointer;
    }
    .token-select img, .fallback-logo {
      width: 24px;
      height: 24px;
      margin-right: 10px;
      object-fit: contain;
    }
    .token-select span { font-size: 16px; }
    .scrollable-tokens {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-top: 10px;
      display: none;
      background-color: #fff;
    }
    /* Search input within token list */
    .token-search {
      width: 100%;
      padding: 8px;
      margin: 10px 0;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 14px;
      box-sizing: border-box;
    }
    /* Container for token items */
    .token-items { }
    .token-item {
      display: flex;
      align-items: center;
      padding: 8px 10px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }
    .token-item:last-child { border-bottom: none; }
    .token-item img {
      width: 24px;
      height: 24px;
      margin-right: 10px;
      object-fit: contain;
    }
    input[type="number"], input[type="text"] {
      width: 100%;
      padding: 10px;
      margin-top: 5px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
    }
    button {
      width: 100%;
      padding: 12px;
      background-color: #3773f5;
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
    }
    button:hover { background-color: #2851a3; }
    .switch-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      margin: 10px auto;
      width: 40px;
      height: 40px;
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 50%;
    }
    .switch-btn:after {
      content: "â†•";
      font-size: 24px;
      color: #3773f5;
    }
    .info-box {
      background-color: #eef1f5;
      border: 1px solid #ccd0d5;
      border-radius: 8px;
      padding: 10px;
      font-size: 14px;
      margin-top: 10px;
    }
    #notifications {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
    }
    .notification {
      background-color: #fff;
      border-left: 5px solid;
      padding: 10px;
      margin-bottom: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .notification.success { border-color: green; }
    .notification.error { border-color: red; }
    .notification.info { border-color: blue; }
    .balance-display { font-size: 14px; margin-top: 5px; }
  </style>
</head>
<body>
  <header>
    <h2>SAggregator</h2>
    <button id="connectWallet">Connect Wallet</button>
  </header>
  <div class="container">
    <div class="swap-section">
      <!-- From Token Section -->
      <div>
        <label>From</label>
        <div class="token-select" id="fromTokenSelect">
          <span id="fromTokenDisplay">
            <img id="fromTokenLogo" src="https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png" alt="Token Logo" />
            <span id="fromTokenSymbol">Select Token</span>
          </span>
        </div>
        <div class="balance-display" id="fromBalanceDisplay">Balance: <span id="fromBalance">-</span></div>
        <div class="scrollable-tokens" id="fromTokenList">
          <!-- Search input and token items will be injected here -->
        </div>
      </div>

      <!-- Switch Pair Button -->
      <div class="switch-btn" id="switchPair"></div>

      <!-- To Token Section -->
      <div>
        <label>To</label>
        <div class="token-select" id="toTokenSelect">
          <span id="toTokenDisplay">
            <img id="toTokenLogo" src="https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png" alt="Token Logo" />
            <span id="toTokenSymbol">Select Token</span>
          </span>
        </div>
        <div class="balance-display" id="toBalanceDisplay">Balance: <span id="toBalance">-</span></div>
        <div class="scrollable-tokens" id="toTokenList">
          <!-- Search input and token items will be injected here -->
        </div>
      </div>

      <!-- Input for Swap Amount (From) -->
      <input type="number" id="fromAmount" placeholder="Amount" />

      <!-- Info Box -->
      <div class="info-box" id="swapInfo">
        <div>Estimated Output: <span id="estimatedOutput">-</span></div>
        <div>Best Router: <span id="bestRouter">-</span></div>
        <div>Price Impact: <span id="priceImpact">-</span></div>
        <div>Aggregator Fee (0.1%): <span id="aggFee">-</span></div>
      </div>

      <!-- Swap Button -->
      <button id="swapButton">Swap</button>
    </div>
  </div>
  <div id="notifications"></div>
  <script>
    // --- Utility: Debounce function to cap RPC calls ---
    function debounce(func, delay) {
      let timer;
      return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => func.apply(this, args), delay);
      }
    }

    // Chain and RPC Info
    const PRIMARY_RPC = "https://testnet-rpc.monad.xyz";
    const CHAIN_ID = 10143;
    const CHAIN_HEX = "0x279f";
    const CHAIN_EXPLORER = "https://testnet.monadexplorer.com/";

    // Default token list (MON is native, WMON is wrapped)
    const defaultTokens = [
      { symbol: "USDC", address: "0xf817257fed379853cDe0fa4F97AB987181B1E5Ea", decimals: 6, logo: "https://cryptologos.cc/logos/usd-coin-usdc-logo.png?v=023" },
      { symbol: "USDT", address: "0x88b8E2161DEDC77EF4ab7585569D2415a1C1055D", decimals: 6, logo: "https://cryptologos.cc/logos/tether-usdt-logo.png?v=040" },
      { symbol: "WMON", address: "0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701", decimals: 18, logo: "https://imagedelivery.net/cBNDGgkrsEA-b_ixIp9SkQ/I_t8rg_V_400x400.jpg/public" },
      { symbol: "MON", address: "MON", decimals: 18, logo: "https://cdn.prod.website-files.com/667c57e6f9254a4b6d914440/667d7104644c621965495f6e_LogoMark.svg" },
      { symbol: "StakeR", address: "0x774453B7A832c83a1BD4adB4ca1e332107432A8f",
        decimals: 18, logo: "https://ttt.0xasif.monster/20250303_043446.png" },
      { symbol: "shMon", address:"0x3a98250F98Dd388C211206983453837C8365BDc1",
        decimals: 18, logo: "https://i.imghippo.com/files/Osf1224Egs.png" },
      { symbol: "Bean", address:"0x268E4E24E0051EC27b3D27A95977E71cE6875a05",
        decimals: 18, logo: "https://swap.bean.exchange/images/tokens/bean.png" }
    ];

    // Array for imported tokens saved in localStorage
    let importedTokens = JSON.parse(localStorage.getItem('importedTokens')) || [];

    let provider, signer, userAddress;
    let aggregatorContract; // Instance of aggregator contract
    const aggregatorAddress = "0x5Dc186D5fDDb5A2A49635F2b1C2459db904F87a5"; // Replace with your deployed contract address
    const aggregatorABI = [
      "function getBestSwap(uint amountIn, address[] calldata path) external view returns (address routerAddress, uint amountOut)",
      "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, uint deadline) external payable returns (uint[] memory amounts)",
      "function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, uint deadline) external returns (uint[] memory amounts)",
      "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, uint deadline) external returns (uint[] memory amounts)",
      "function getPriceImpact(address router, address tokenIn, address tokenOut, uint amountIn) external view returns (uint priceImpact)"
    ];

    // WMON wrapping interface (assumed similar to WETH)
    const wmonABI = [
      "function deposit() payable",
      "function withdraw(uint wad)"
    ];

    let fromToken = null;
    let toToken = null;

    // --- Notification System ---
    function notify(message, type="info") {
      const notifications = document.getElementById("notifications");
      const div = document.createElement("div");
      div.className = "notification " + type;
      div.innerHTML = message;
      notifications.appendChild(div);
      setTimeout(() => { div.remove(); }, 6000);
    }

    // Format wallet address: e.g. 0x0***00
    function formatAddress(addr) {
      return addr.substring(0, 6) + '***' + addr.substring(addr.length - 4);
    }

    // --- Wallet Connection ---
    async function connectWallet() {
      if (window.ethereum) {
        try {
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          provider = new ethers.providers.Web3Provider(window.ethereum);
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          document.getElementById("connectWallet").innerText = formatAddress(userAddress);
          notify("Wallet connected: " + formatAddress(userAddress), "success");
          const network = await provider.getNetwork();
          if (network.chainId !== CHAIN_ID) {
            try {
              await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: CHAIN_HEX }]
              });
            } catch (switchError) {
              notify("Please switch to the correct network", "error");
              return;
            }
          }
          aggregatorContract = new ethers.Contract(aggregatorAddress, aggregatorABI, signer);
        } catch (error) {
          console.error(error);
          notify("Wallet connection failed", "error");
        }
      } else {
        notify("Please install MetaMask", "error");
      }
    }
    document.getElementById("connectWallet").addEventListener("click", connectWallet);

    // --- Import Token (called when user pastes a valid contract address in the search input) ---
    async function importToken(address) {
      try {
        const tokenContract = new ethers.Contract(address, [
          "function symbol() view returns (string)",
          "function decimals() view returns (uint8)",
          "function balanceOf(address) view returns (uint)"
        ], provider);
        const symbol = await tokenContract.symbol();
        const decimals = await tokenContract.decimals();
        let logo = "?";
        const token = { symbol, address, decimals, logo };
        importedTokens.push(token);
        localStorage.setItem('importedTokens', JSON.stringify(importedTokens));
        notify("Token imported: " + symbol, "success");
        return token;
      } catch (error) {
        console.error(error);
        notify("Failed to import token", "error");
        return null;
      }
    }

    // --- Token List Loading with Search ---
    function loadTokens() {
      const tokens = [...defaultTokens, ...importedTokens];
      
      // From token list
      const fromList = document.getElementById("fromTokenList");
      fromList.innerHTML = "";
      const fromSearch = document.createElement("input");
      fromSearch.type = "text";
      fromSearch.placeholder = "Search token symbol or paste contract address";
      fromSearch.className = "token-search";
      fromList.appendChild(fromSearch);
      const fromItemsContainer = document.createElement("div");
      fromItemsContainer.className = "token-items";
      fromList.appendChild(fromItemsContainer);
      
      // To token list
      const toList = document.getElementById("toTokenList");
      toList.innerHTML = "";
      const toSearch = document.createElement("input");
      toSearch.type = "text";
      toSearch.placeholder = "Search token symbol or paste contract address";
      toSearch.className = "token-search";
      toList.appendChild(toSearch);
      const toItemsContainer = document.createElement("div");
      toItemsContainer.className = "token-items";
      toList.appendChild(toItemsContainer);
      
      // Helper: Render token items with a provided onSelect callback
      function renderTokenItems(container, tokensArray, onSelect) {
        container.innerHTML = "";
        tokensArray.forEach(token => {
          const item = document.createElement("div");
          item.className = "token-item";
          if(token.logo && token.logo !== "?") {
            item.innerHTML = `<img src="${token.logo}" alt="${token.symbol} Logo"><span>${token.symbol}</span>`;
          } else {
            item.innerHTML = `<img src="https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png" alt="Default Token Logo" class="fallback-logo"><span>${token.symbol}</span>`;
          }
          item.addEventListener("click", () => {
            onSelect(token);
          });
          container.appendChild(item);
        });
      }
      
      // Set up search input for From list
      fromSearch.addEventListener("input", debounce(async function(e) {
        const term = e.target.value.trim().toLowerCase();
        let filtered = tokens.filter(token => token.symbol.toLowerCase().includes(term));
        if(term.startsWith("0x") && term.length === 42) {
          const exists = tokens.find(t => t.address.toLowerCase() === term);
          if(!exists) {
            const importedToken = await importToken(term);
            if(importedToken) {
              tokens.push(importedToken);
              filtered = tokens.filter(token => token.symbol.toLowerCase().includes(term) || token.address.toLowerCase() === term);
            }
          } else {
            filtered = [exists];
          }
        }
        renderTokenItems(fromItemsContainer, filtered, (token) => {
          fromToken = token;
          document.getElementById("fromTokenLogo").src = (token.logo && token.logo !== "?") ? token.logo : "https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png";
          document.getElementById("fromTokenSymbol").innerText = token.symbol;
          fromList.style.display = "none";
          fetchTokenBalance(token, "from");
          estimateSwap();
        });
      }, 300));
      
      // Set up search input for To list
      toSearch.addEventListener("input", debounce(async function(e) {
        const term = e.target.value.trim().toLowerCase();
        let filtered = tokens.filter(token => token.symbol.toLowerCase().includes(term));
        if(term.startsWith("0x") && term.length === 42) {
          const exists = tokens.find(t => t.address.toLowerCase() === term);
          if(!exists) {
            const importedToken = await importToken(term);
            if(importedToken) {
              tokens.push(importedToken);
              filtered = tokens.filter(token => token.symbol.toLowerCase().includes(term) || token.address.toLowerCase() === term);
            }
          } else {
            filtered = [exists];
          }
        }
        renderTokenItems(toItemsContainer, filtered, (token) => {
          toToken = token;
          document.getElementById("toTokenLogo").src = (token.logo && token.logo !== "?") ? token.logo : "https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png";
          document.getElementById("toTokenSymbol").innerText = token.symbol;
          toList.style.display = "none";
          fetchTokenBalance(token, "to");
          estimateSwap();
        });
      }, 300));
      
      // Initially render full list for both From and To lists
      renderTokenItems(fromItemsContainer, tokens, (token) => {
        fromToken = token;
        document.getElementById("fromTokenLogo").src = (token.logo && token.logo !== "?") ? token.logo : "https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png";
        document.getElementById("fromTokenSymbol").innerText = token.symbol;
        fromList.style.display = "none";
        fetchTokenBalance(token, "from");
        estimateSwap();
      });
      renderTokenItems(toItemsContainer, tokens, (token) => {
        toToken = token;
        document.getElementById("toTokenLogo").src = (token.logo && token.logo !== "?") ? token.logo : "https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png";
        document.getElementById("toTokenSymbol").innerText = token.symbol;
        toList.style.display = "none";
        fetchTokenBalance(token, "to");
        estimateSwap();
      });
    }
    loadTokens();

    // Allow re-opening token lists by clicking on token-select areas
    document.getElementById("fromTokenSelect").addEventListener("click", () => {
      const list = document.getElementById("fromTokenList");
      list.style.display = (list.style.display === "none" || list.style.display === "") ? "block" : "none";
    });
    document.getElementById("toTokenSelect").addEventListener("click", () => {
      const list = document.getElementById("toTokenList");
      list.style.display = (list.style.display === "none" || list.style.display === "") ? "block" : "none";
    });

    // --- Default Pair: MON -> USDT ---
    function setDefaultPair() {
      const mon = defaultTokens.find(t => t.symbol === "MON");
      const usdt = defaultTokens.find(t => t.symbol === "USDT");
      if(mon && usdt) {
        fromToken = mon;
        toToken = usdt;
        document.getElementById("fromTokenLogo").src = (mon.logo && mon.logo !== "?") ? mon.logo : "https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png";
        document.getElementById("fromTokenSymbol").innerText = mon.symbol;
        document.getElementById("toTokenLogo").src = (usdt.logo && usdt.logo !== "?") ? usdt.logo : "https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png";
        document.getElementById("toTokenSymbol").innerText = usdt.symbol;
        fetchTokenBalance(mon, "from");
        fetchTokenBalance(usdt, "to");
      }
    }
    setDefaultPair();

    // --- Switch Pair Button ---
    document.getElementById("switchPair").addEventListener("click", () => {
      const temp = fromToken;
      fromToken = toToken;
      toToken = temp;
      // Update UI
      document.getElementById("fromTokenLogo").src = (fromToken.logo && fromToken.logo !== "?") ? fromToken.logo : "https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png";
      document.getElementById("fromTokenSymbol").innerText = fromToken.symbol;
      document.getElementById("toTokenLogo").src = (toToken.logo && toToken.logo !== "?") ? toToken.logo : "https://ttt.0xasif.monster/pngtree-orange-round-faq-icon-for-help-and-questions-vector-png-image_48543232-removebg-preview.png";
      document.getElementById("toTokenSymbol").innerText = toToken.symbol;
      fetchTokenBalance(fromToken, "from");
      fetchTokenBalance(toToken, "to");
      estimateSwap();
    });

    // --- Fetch and Display Token Balance ---
    async function fetchTokenBalance(token, side) {
      if(!provider || !userAddress) return;
      try {
        let balance;
        if(token.symbol === "MON") {
          balance = await provider.getBalance(userAddress);
          balance = ethers.utils.formatEther(balance);
        } else {
          const tokenContract = new ethers.Contract(token.address, ["function balanceOf(address) view returns (uint)"], provider);
          balance = await tokenContract.balanceOf(userAddress);
          balance = ethers.utils.formatUnits(balance, token.decimals);
        }
        if(side === "from") {
          document.getElementById("fromBalance").innerText = balance;
        } else {
          document.getElementById("toBalance").innerText = balance;
        }
      } catch (err) { console.error(err); }
    }

    // --- Estimate Swap (debounced) ---
    async function estimateSwap() {
      const amountIn = document.getElementById("fromAmount").value;
      if(!fromToken || !toToken || !amountIn || isNaN(amountIn)) return;
      // If swapping between MON and WMON (either direction), force 1:1 rate.
      if ((fromToken.symbol === "MON" && toToken.symbol === "WMON") || (fromToken.symbol === "WMON" && toToken.symbol === "MON")) {
        document.getElementById("estimatedOutput").innerText = amountIn;
        document.getElementById("bestRouter").innerText = "N/A";
        document.getElementById("priceImpact").innerText = "0%";
      } else {
        let amountInParsed;
        if(fromToken.symbol === "MON") {
          amountInParsed = ethers.utils.parseEther(amountIn);
        } else {
          amountInParsed = ethers.utils.parseUnits(amountIn, fromToken.decimals);
        }
        // Build swap path. For native swaps, assume WMON is the wrapped intermediary.
        let path;
        if(fromToken.symbol === "MON" || toToken.symbol === "MON") {
          if(fromToken.symbol === "MON") {
            path = [defaultTokens.find(t => t.symbol === "WMON").address, toToken.address];
          } else {
            path = [fromToken.address, defaultTokens.find(t => t.symbol === "WMON").address];
          }
        } else {
          path = [fromToken.address, toToken.address];
        }
        try {
          const deadline = Math.floor(Date.now() / 1000) + 1800;
          const bestSwap = await aggregatorContract.getBestSwap(amountInParsed, path);
          document.getElementById("estimatedOutput").innerText = ethers.utils.formatUnits(bestSwap[1], toToken.decimals);
          document.getElementById("bestRouter").innerText = bestSwap[0];
          try {
            const priceImpact = await aggregatorContract.getPriceImpact(bestSwap[0], path[0], path[1], amountInParsed);
            document.getElementById("priceImpact").innerText = (parseFloat(ethers.utils.formatUnits(priceImpact, 18)) * 100).toFixed(2) + "%";
          } catch (err) {
            document.getElementById("priceImpact").innerText = "N/A";
          }
        } catch (error) {
          console.error(error);
          notify("Estimation failed", "error");
        }
      }
      // Compute Aggregator Fee (0.1% of input)
      let fee;
      if(fromToken.symbol === "MON") {
        fee = ethers.utils.parseEther(amountIn).div(1000);
        document.getElementById("aggFee").innerText = ethers.utils.formatEther(fee) + " MON";
      } else {
        fee = ethers.utils.parseUnits(amountIn, fromToken.decimals).div(1000);
        document.getElementById("aggFee").innerText = ethers.utils.formatUnits(fee, fromToken.decimals) + " " + fromToken.symbol;
      }
    }
    document.getElementById("fromAmount").addEventListener("input", debounce(estimateSwap, 200));

    // --- Perform Swap (including wrapping/unwrapping if needed) ---
    async function performSwap() {
      if(!fromToken || !toToken) {
        notify("Please select both tokens", "error");
        return;
      }
      const amountIn = document.getElementById("fromAmount").value;
      if(!amountIn || isNaN(amountIn)) {
        notify("Enter a valid amount", "error");
        return;
      }
      let amountInParsed;
      if(fromToken.symbol === "MON") {
        amountInParsed = ethers.utils.parseEther(amountIn);
      } else {
        amountInParsed = ethers.utils.parseUnits(amountIn, fromToken.decimals);
      }
      const deadline = Math.floor(Date.now() / 1000) + 1800;
      try {
        let tx;
        // Wrapping: MON -> WMON
        if(fromToken.symbol === "MON" && toToken.symbol === "WMON") {
          const wmonContract = new ethers.Contract(defaultTokens.find(t => t.symbol === "WMON").address, wmonABI, signer);
          tx = await wmonContract.deposit({ value: amountInParsed });
          notify("Wrapping in process: " + tx.hash + ` <a href="${CHAIN_EXPLORER}/tx/${tx.hash}" target="_blank">View in Explorer</a>`, "info");
          await tx.wait();
          notify("Wrap successful!", "success");
          return;
        }
        // Unwrapping: WMON -> MON
        else if(fromToken.symbol === "WMON" && toToken.symbol === "MON") {
          const wmonContract = new ethers.Contract(defaultTokens.find(t => t.symbol === "WMON").address, wmonABI, signer);
          tx = await wmonContract.withdraw(amountInParsed);
          notify("Unwrapping in process: " + tx.hash + ` <a href="${CHAIN_EXPLORER}/tx/${tx.hash}" target="_blank">View in Explorer</a>`, "info");
          await tx.wait();
          notify("Unwrap successful!", "success");
          return;
        }
        // Regular swap via aggregator
        let path = (fromToken.symbol === "MON" || toToken.symbol === "MON") ?
          (fromToken.symbol === "MON" ? [defaultTokens.find(t => t.symbol === "WMON").address, toToken.address] : [fromToken.address, defaultTokens.find(t => t.symbol === "WMON").address])
          : [fromToken.address, toToken.address];
        const bestSwap = await aggregatorContract.getBestSwap(amountInParsed, path);
        const amountOutMin = bestSwap[1].mul(95).div(100);
        if(fromToken.symbol === "MON") {
          tx = await aggregatorContract.swapExactETHForTokens(amountOutMin, path, deadline, { value: amountInParsed });
        } else if(toToken.symbol === "MON") {
          const tokenContract = new ethers.Contract(fromToken.address, ["function approve(address spender, uint amount) returns (bool)"], signer);
          const approveTx = await tokenContract.approve(aggregatorAddress, amountInParsed);
          await approveTx.wait();
          tx = await aggregatorContract.swapExactTokensForETH(amountInParsed, amountOutMin, path, deadline);
        } else {
          const tokenContract = new ethers.Contract(fromToken.address, ["function approve(address spender, uint amount) returns (bool)"], signer);
          const approveTx = await tokenContract.approve(aggregatorAddress, amountInParsed);
          await approveTx.wait();
          tx = await aggregatorContract.swapExactTokensForTokens(amountInParsed, amountOutMin, path, deadline);
        }
        notify("Swap transaction sent: " + tx.hash + ` <a href="${CHAIN_EXPLORER}/tx/${tx.hash}" target="_blank">View in Explorer</a>`, "info");
        await tx.wait();
        notify("Swap successful! " + ` <a href="${CHAIN_EXPLORER}/tx/${tx.hash}" target="_blank">View in Explorer</a>`, "success");
      } catch (error) {
        console.error(error);
        notify("Swap failed", "error");
      }
    }
    document.getElementById("swapButton").addEventListener("click", performSwap);
  </script>
</body>
</html>
